use clap::Parser;
use coyan_fta::fault_tree::FaultTree;
use coyan_fta::formula::CNFFormat;
use coyan_fta::solver::*;
use coyan_rft::random_fault_trees::{RFTConfig, RFaultTree};
use itertools::Itertools;
use rand::Rng;
use rayon::iter::{IntoParallelIterator, ParallelIterator};
use serde_json::json;
use std::collections::HashMap;
use std::path::Path;
use std::time::Instant;
use std::{fmt::Debug, str::FromStr};
use structs::{RandomGenerationCommand, *};
mod structs;

#[derive(Parser, Debug)]
#[command(
    author = "Nazareno Garagiola",
    version = "0.1",
    about = "
        Coyan is a Rust project that transforms Static Fault Trees into CNF equisatisfiables formulas. 
        Then, with the use of a Model Counter, computes the Top Event Probabilty (TEP) of failure at one or more given time points.
    "
)]
struct Arguments {
    #[clap(subcommand)]
    command: Command,
}

#[derive(Parser, Clone, Debug)]
enum Command {
    #[clap(
        about = "Outputs information about the FT: the amount of basic events, of gates and the number of clauses generated by the method."
    )]
    Info(InfoCommand),
    #[clap(
        about = "Translates the FT implicit formula to a CNF equisatisfiable formula. Outputs a DIMACS file with a wcnf file."
    )]
    Translate(TranslateCommand),
    #[clap(
        about = "Executes a Solver to obtain the TEP of the FT at a given timepoint or timebound."
    )]
    Solve(SolveCommand),
    #[clap(
        about = "Computes the Criticality Measure for all the BE. Each thread runs 1 FT at the time."
    )]
    Importance(ImportanceCommand),
    #[clap(
        about = "Modularize the input FT, compute the TEP of each module and replace it with a BE with the same probability. Finally, obtain the TEP of the entire FT."
    )]
    Modularize(ModCommand),
    #[clap(about = "Generate a Static Random FT.")]
    RFT(RandomGenerationCommand),
}

/// Outputs relevant information about the FT.
fn ft_info(command: InfoCommand) {
    let dft_filename = command.input;
    let simplify = command.simplify;
    let path = Path::new(dft_filename.as_str());
    let model_name = path.file_name().unwrap();
    let mut ft = FaultTree::new_from_file(&dft_filename, simplify, false);
    let top_type = ft.nodes[ft.root_id].kind.type_is();
    let (num_be, num_gates, num_clauses) = ft.get_info(command.preprocess);
    let num_modules = if command.modularize {
        Some(ft.modularize_ft().len())
    } else {
        None
    };
    println!(
        "{}",
        json!({
            "model": model_name.to_str(),
            "top type": top_type,
            "num_basic_events": num_be,
            "num_gates": num_gates,
            "num_clauses": num_clauses,
            "num_submodules": num_modules
        })
    );
}

/// Translates the FT explicit formula to a CNF file.
fn translate(command: TranslateCommand) {
    let dft_filename = command.input;
    let cnf_filename = command.output;
    let w_file = command.w_file;
    let simplify = command.config.simplify;
    let path = Path::new(dft_filename.as_str());
    let model_name = path.file_name().unwrap();
    let format =
        CNFFormat::from_str(&command.config.format).expect("Unsupported format. Try MCC or MC21.");

    let time_start = Instant::now();
    let ft = FaultTree::new_from_file(&dft_filename, simplify, command.config.negate_or);
    match command.timebounds {
        None => {
            let cnf_path = format!("{}.cnf", cnf_filename);
            ft.dump_cnf_to_file(
                cnf_path,
                format,
                command.timepoint,
                w_file,
                command.config.preprocess,
            );
            let duration = time_start.elapsed();
            println!(
                "{}",
                json!({
                    "model": model_name.to_str(),
                    "duration": format!("{:?}", duration),
                })
            );
        }
        Some(ts) => {
            let (start, end, step) = (ts[0], ts[1], ts[2]);
            let n_steps = if step != 0.0 {
                (end / step) as i64 + 1
            } else {
                2
            };
            let timebounds = (start as i64..n_steps)
                .into_iter()
                .map(|v| start + ((100 * v) as f64 * step).round() / 100.0)
                .collect_vec();
            for t in timebounds {
                let cnf_path = format!("{}_t={}.wcnf", cnf_filename, t);
                ft.dump_cnf_to_file(
                    cnf_path,
                    format,
                    t.to_owned(),
                    w_file.clone(),
                    command.config.preprocess.clone(),
                );
                let duration = time_start.elapsed();
                println!(
                    "{}",
                    json!({
                        "model": model_name.to_str(),
                        "duration": format!("{:?}", duration),
                    })
                );
            }
        }
    }
}

/// Compute TEP of FT, given a solver and the configuration needed.
/// Can perform multiple timepoints if range was given and use multi-threading
/// to handle each run.
fn compute_tep(command: SolveCommand) {
    let dft_filename = command.input;
    let solver_path = command.solver_path;
    let verbose = command.config.verb;
    let timeout_s = command.config.timeout_s;
    let preprocess = command.config.preprocess;
    let format =
        CNFFormat::from_str(&command.config.format).expect("Unsupported format. Try MCC or MC21.");

    rayon::ThreadPoolBuilder::new()
        .num_threads(command.config.num_threads)
        .build_global()
        .unwrap();

    let max_size = command.config.max_cache_size / command.config.num_threads;

    let time_start = Instant::now();
    let ft = FaultTree::new_from_file(
        &dft_filename,
        command.config.simplify,
        command.config.negate_or,
    );
    let mut solver: Box<dyn Solver + Sync> = get_solver_from_path(&solver_path);
    solver._set_cache_size(command.config.max_cache_size);
    match command.timebounds.clone() {
        None => {
            let tep = solver.compute_probabilty(
                &ft,
                format,
                command.timepoint,
                command.config.timeout_s,
                preprocess,
                command.config.negate_or,
            );
            let duration = time_start.elapsed();
            if !verbose {
                println!(
                    "{}",
                    json!({
                        "TEP": tep,
                        "timepoint": command.timepoint
                    })
                )
            } else {
                let path = Path::new(dft_filename.as_str());
                let model_name = path.file_name().unwrap();
                println!(
                    "{}",
                    json!({
                        "model": model_name.to_str(),
                        "timepoint": command.timepoint,
                        "TEP": tep,
                        "duration": format!("{:?}", duration)
                    })
                );
            };
        }
        Some(ts) => {
            solver._set_cache_size(max_size);
            let (start, end, step) = (ts[0], ts[1], ts[2]);
            let n_steps = if step != 0.0 {
                (end / step) as i64 + 1
            } else {
                2
            };
            let timebounds = (start as i64..n_steps)
                .into_iter()
                .map(|v| start + ((100 * v) as f64 * step).round() / 100.0)
                .collect_vec();
            let probs: HashMap<String, f64> = timebounds
                .into_par_iter()
                .filter_map(|t| {
                    if t > end {
                        None
                    } else {
                        let tep = solver.compute_probabilty(
                            &ft,
                            format,
                            t,
                            timeout_s,
                            preprocess.clone(),
                            command.config.negate_or,
                        );
                        Some((format!("t={}", t), tep))
                    }
                })
                .collect::<HashMap<String, f64>>();
            let duration = time_start.elapsed();

            let path = Path::new(dft_filename.as_str());
            let model_name = path.file_name().unwrap();
            if verbose {
                println!(
                    "{}",
                    json!({
                        "model": model_name.to_str(),
                        "values": probs,
                        "duration": format!("{:?}", duration),
                    })
                );
            } else {
                println!(
                    "{}",
                    json!({
                        "model": model_name.to_str(),
                        "duration": format!("{:?}", duration),
                        "timebounds": command.timebounds
                    })
                )
            };
        }
    }
}

/// Compute Criticality and Birnbaum Measures for all of the Basic Event in the FT
/// Can be time consuming.
/// Future Work: Paralelize with threads
fn compute_importance_measures(command: ImportanceCommand) {
    let dft_filename = command.input;
    let path = Path::new(dft_filename.as_str());
    let model_name = path.file_name().unwrap();
    let format =
        CNFFormat::from_str(&command.config.format).expect("Unsupported format. Try MCC or MC21.");
    let mut solver: Box<dyn Solver + Sync> = get_solver_from_path(&command.solver_path);

    rayon::ThreadPoolBuilder::new()
        .num_threads(command.config.num_threads)
        .build_global()
        .unwrap();

    let max_size = command.config.max_cache_size / command.config.num_threads;
    solver._set_cache_size(max_size);

    let ft = FaultTree::new_from_file(
        &dft_filename,
        command.config.simplify,
        command.config.negate_or,
    );
    let time_start = Instant::now();

    if command.config.display {
        println!(
            "Measuring importance measures for {:?} basic events.",
            ft.get_info(None).0
        );
    }

    let measures =
        ft.importance_measures(&solver, format, command.timepoint, command.config.negate_or);
    let elapsed = time_start.elapsed();

    println!(
        "{}",
        json!({
            "model": model_name.to_str(),
            "timepoint": command.timepoint,
            "duration": format!("{:?}", elapsed),
            "measures": measures,
        })
    );
}

fn modularize_ft(command: ModCommand) {
    let dft_filename = command.input;
    let format =
        CNFFormat::from_str(&command.config.format).expect("Unsupported format. Try MCC or MC21.");
    let solver_path = command.solver_path;
    let mut solver: Box<dyn Solver + Sync> = get_solver_from_path(&solver_path);
    let path = Path::new(dft_filename.as_str());
    let model_name = path.file_name().unwrap();

    rayon::ThreadPoolBuilder::new()
        .num_threads(command.config.num_threads)
        .build_global()
        .unwrap();

    // Distribute cache use for each thread.
    let max_size = command.config.max_cache_size / command.config.num_threads;
    solver._set_cache_size(max_size);

    let mut ft = FaultTree::new_from_file(
        &dft_filename,
        command.config.simplify,
        command.config.negate_or,
    );

    let info_pre = ft.get_info(None);

    let time_start = Instant::now();
    let mut module_ids = ft.modularize_ft();
    let num_modules = module_ids.len();
    // The DFS search leaves the bottom module ids on the end, by reversing it,
    // we make sure that it starts replacing the modules that are deeper in the tree.
    module_ids.reverse();

    ft.replace_modules(
        &solver,
        module_ids,
        format,
        command.timepoint,
        command.config.timeout_s,
        command.config.num_threads,
        command.config.negate_or,
        command.config.display,
    );

    let time_modularisation = time_start.elapsed();
    let info_post = ft.get_info(None);
    // Reset Cache max size for the last execution.
    solver._set_cache_size(command.config.max_cache_size);

    if command.config.display {
        println!(
            "Replaced a total of {:?} modules. From {:?} to {:?} (BEs, Gates, Clauses).\nSolving final Fault Tree.",
            num_modules, info_pre, info_post
        );
    }
    let time_start = Instant::now();

    let tep = solver.compute_probabilty(
        &ft,
        format,
        command.timepoint,
        command.config.timeout_s,
        command.config.preprocess,
        command.config.negate_or,
    );
    let elapsed = time_start.elapsed();

    println!(
        "{}",
        json!({
            "#modules" : num_modules,
            "model": model_name.to_str(),
            "timepoint": command.timepoint,
            "TEP": tep,
            "duration": format!("{:?}", elapsed),
            "duration_mod": format!("{:?}", time_modularisation),
        })
    );
}

fn random_ft(comm: RandomGenerationCommand) {
    let n_nodes = comm.n_nodes;
    let rates = vec![comm.rate_be, comm.rate_and, comm.rate_or, comm.rate_vot];
    let output_filename = comm.output;
    let seed = comm.seed;

    let seed = match seed {
        None => {
            let mut rng = rand::thread_rng();
            rng.gen_range(u16::MIN..u16::MAX) as u64
        }
        Some(u) => u,
    };

    let output_filename = if !output_filename.ends_with(".dft") {
        format!("{}.dft", output_filename)
    } else {
        output_filename
    };

    let config = RFTConfig::from_vec(rates);
    let solver_cmd = &comm.solver_path;

    let start = Instant::now();
    let rft = RFaultTree::new_random(
        n_nodes,
        config,
        comm.prob_multiplier,
        comm.perc_last,
        seed,
        comm.max_n_children,
    );

    match solver_cmd {
        Option::None => {
            rft.save_to_dft(output_filename);
            let duration = start.elapsed();
            println!(
                "{}",
                json!({
                    "time_elapsed": format!("{:?}", duration),
                })
            );
        }
        Option::Some(cmd) => {
            let solver = get_solver_from_path(&cmd);
            rft.save_to_dft(output_filename);
            let ft = rft.extract_ft();
            let wmc =
                solver.compute_probabilty(&ft, CNFFormat::MC21, 1.0, comm.timeout_s, None, false);
            let duration = start.elapsed();

            println!(
                "{}",
                json!({
                    "tep": wmc,
                    "time_elapsed": format!("{:?}", duration),
                })
            );
        }
    }
}

fn main() {
    let arguments = Arguments::parse();
    match arguments.command {
        Command::Info(command) => ft_info(command),
        Command::Solve(command) => compute_tep(command),
        Command::Translate(command) => translate(command),
        Command::Importance(command) => compute_importance_measures(command),
        Command::Modularize(command) => modularize_ft(command),
        Command::RFT(command) => random_ft(command),
    }
}
