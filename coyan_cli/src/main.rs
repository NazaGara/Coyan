use clap::Parser;
use coyan_fta::fault_tree::FaultTree;
use coyan_fta::formula::CNFFormat;
use coyan_fta::solver::*;
use coyan_rft::rft_generator::{RFTConfig, RFaultTree};
use serde_json::json;
use std::path::Path;
use std::time::Instant;
use std::{fmt::Debug, str::FromStr};
use structs::{RandomGenerationCommand, *};
mod structs;

#[derive(Parser, Debug)]
#[command(
    author = "Nazareno Garagiola",
    version = "0.1",
    about = "
        Coyan is a Rust project that transforms Static Fault Trees into CNF equisatisfiables formulas. 
        Then, with the use of a Model Counter, computes the Top Event Probabilty (TEP) of failure at one or more given time points.
    "
)]
struct Arguments {
    #[clap(subcommand)]
    command: Command,
}

#[derive(Parser, Clone, Debug)]
enum Command {
    #[clap(
        about = "Outputs information about the FT: the amount of basic events, of gates and the number of clauses generated by the method."
    )]
    Info(InfoCommand),
    #[clap(
        about = "Translates the FT implicit formula to a CNF equisatisfiable formula. Outputs a DIMACS file with a wcnf file."
    )]
    Translate(TranslateCommand),
    #[clap(
        about = "Executes a Solver to obtain the TEP of the FT at a given timepoint or timebound."
    )]
    Solve(SolveCommand),
    #[clap(
        about = "Computes the Criticality Measure for all the BE. Each thread runs 1 FT at the time."
    )]
    Importance(ImportanceCommand),
    #[clap(
        about = "Modularize the input FT, compute the TEP of each module and replace it with a BE with the same probability. Finally, obtain the TEP of the entire FT."
    )]
    Modularize(ModCommand),
    #[clap(about = "Generate a Static Random FT.")]
    Rft(RandomGenerationCommand),
}

/// Outputs relevant information about the FT.
fn ft_info(command: InfoCommand) {
    let dft_filename = command.input;
    let simplify = command.simplify;
    let path = Path::new(dft_filename.as_str());
    let model_name = path.file_name().unwrap();
    let mut ft = FaultTree::new_from_file(&dft_filename, simplify, false);
    let top_type = ft.nodes[ft.root_id].gate_type();
    let (num_be, num_gates, num_clauses) = ft.get_info(command.preprocess);
    let num_modules = if command.modularize {
        Some(ft.modularize_ft().len())
    } else {
        None
    };
    println!(
        "{}",
        json!({
            "model": model_name.to_str(),
            "top type": top_type,
            "num_basic_events": num_be,
            "num_gates": num_gates,
            "num_clauses": num_clauses,
            "num_submodules": num_modules
        })
    );
}

/// Translates the FT explicit formula to a CNF file.
fn translate(command: TranslateCommand) {
    let dft_filename = command.input;
    let cnf_filename = command.output;
    let w_file = command.w_file;
    let simplify = command.config.simplify;
    let path = Path::new(dft_filename.as_str());
    let model_name = path.file_name().unwrap();
    let format =
        CNFFormat::from_str(&command.config.format).expect("Unsupported format. Try MCC or MC21.");

    let time_start = Instant::now();
    let ft = FaultTree::new_from_file(&dft_filename, simplify, command.config.negate_or);

    ft.dump_cnf_to_file(
        format!("{}.cnf", cnf_filename),
        format,
        command.timepoint,
        w_file,
        command.config.preprocess,
        command.unavailability,
    );

    let duration = time_start.elapsed();
    println!(
        "{}",
        json!({
            "model": model_name.to_str(),
            "duration": format!("{:?}", duration),
        })
    );
}

/// Compute TEP of FT, given a solver and the configuration needed.
/// Can perform multiple timepoints if range was given and use multi-threading
/// to handle each run.
fn compute_tep(command: SolveCommand) {
    let dft_filename = command.input;
    let solver_path = command.solver_path;
    let verbose = command.config.verb;
    let format =
        CNFFormat::from_str(&command.config.format).expect("Unsupported format. Try MCC or MC21.");

    let time_start = Instant::now();
    let ft = FaultTree::new_from_file(
        &dft_filename,
        command.config.simplify,
        command.config.negate_or,
    );
    let mut solver: Box<dyn Solver + Sync> = get_solver_from_path(&solver_path);
    solver._set_cache_size(command.config.max_cache_size);

    let tep = solver.compute(
        &ft,
        format,
        command.timepoint,
        command.config.timeout_s,
        command.config.preprocess,
        command.config.negate_or,
        command.unavailability,
    );
    let duration = time_start.elapsed();
    if !verbose {
        println!(
            "{}",
            json!({
                "TEP": tep,
                "timepoint": command.timepoint
            })
        )
    } else {
        let path = Path::new(dft_filename.as_str());
        let model_name = path.file_name().unwrap();
        println!(
            "{}",
            json!({
                "model": model_name.to_str(),
                "timepoint": command.timepoint,
                "TEP": tep,
                "duration": format!("{:?}", duration)
            })
        );
    };
}

/// Compute Criticality and Birnbaum Measures for all of the Basic Event in the FT
/// Can be time consuming.
/// Future Work: Paralelize with threads
fn compute_importance_measures(command: ImportanceCommand) {
    let dft_filename = command.input;
    let path = Path::new(dft_filename.as_str());
    let model_name = path.file_name().unwrap();
    let format =
        CNFFormat::from_str(&command.config.format).expect("Unsupported format. Try MCC or MC21.");
    let mut solver: Box<dyn Solver + Sync> = get_solver_from_path(&command.solver_path);

    rayon::ThreadPoolBuilder::new()
        .num_threads(command.config.num_threads)
        .build_global()
        .unwrap();

    let max_size = command.config.max_cache_size / command.config.num_threads;
    solver._set_cache_size(max_size);

    let ft = FaultTree::new_from_file(
        &dft_filename,
        command.config.simplify,
        command.config.negate_or,
    );
    let time_start = Instant::now();

    if command.config.display {
        println!(
            "Measuring importance measures for {:?} basic events.",
            ft.get_info(None).0
        );
    }

    let measures = ft.importance_measures(
        solver.as_ref(),
        format,
        command.timepoint,
        command.config.negate_or,
    );
    let elapsed = time_start.elapsed();

    println!(
        "{}",
        json!({
            "model": model_name.to_str(),
            "timepoint": command.timepoint,
            "duration": format!("{:?}", elapsed),
            "measures": measures,
        })
    );
}

fn modularize_ft(command: ModCommand) {
    let dft_filename = command.input;
    let format =
        CNFFormat::from_str(&command.config.format).expect("Unsupported format. Try MCC or MC21.");
    let solver_path = command.solver_path;
    let mut solver: Box<dyn Solver + Sync> = get_solver_from_path(&solver_path);
    let path = Path::new(dft_filename.as_str());
    let model_name = path.file_name().unwrap();

    rayon::ThreadPoolBuilder::new()
        .num_threads(command.config.num_threads)
        .build_global()
        .unwrap();

    // Distribute cache use for each thread.
    let max_size = command.config.max_cache_size / command.config.num_threads;
    solver._set_cache_size(max_size);

    let mut ft = FaultTree::new_from_file(
        &dft_filename,
        command.config.simplify,
        command.config.negate_or,
    );

    let info_pre = ft.get_info(None);

    let time_start = Instant::now();
    let mut module_ids = ft.modularize_ft();
    let num_modules = module_ids.len();
    // The DFS search leaves the bottom module ids on the end, by reversing it,
    // we make sure that it starts replacing the modules that are deeper in the tree.
    module_ids.reverse();

    ft.replace_modules(
        solver.as_ref(),
        module_ids,
        format,
        command.timepoint,
        command.config.timeout_s,
        command.config.num_threads,
        command.config.negate_or,
        command.config.display,
    );

    let time_modularisation = time_start.elapsed();
    let info_post = ft.get_info(None);
    // Reset Cache max size for the last execution.
    solver._set_cache_size(command.config.max_cache_size);

    if command.config.display {
        println!(
            "Replaced a total of {:?} modules. From {:?} to {:?} (BEs, Gates, Clauses).\nSolving final Fault Tree.",
            num_modules, info_pre, info_post
        );
    }
    let time_start = Instant::now();

    let tep = solver.compute(
        &ft,
        format,
        command.timepoint,
        command.config.timeout_s,
        command.config.preprocess,
        command.config.negate_or,
        false,
    );
    let elapsed = time_start.elapsed();

    println!(
        "{}",
        json!({
            "#modules" : num_modules,
            "model": model_name.to_str(),
            "timepoint": command.timepoint,
            "TEP": tep,
            "duration": format!("{:?}", elapsed),
            "duration_mod": format!("{:?}", time_modularisation),
        })
    );
}

fn random_ft(comm: RandomGenerationCommand) {
    let n_nodes = comm.n_nodes;
    let rates = vec![comm.rate_be, comm.rate_and, comm.rate_or, comm.rate_vot];
    let output_filename = comm.output;
    let seed = comm.seed.unwrap_or(42);

    let output_filename = if !output_filename.ends_with(".dft") {
        format!("{}.dft", output_filename)
    } else {
        output_filename
    };

    let config = RFTConfig::from_vec(rates);
    let solver_cmd = &comm.solver_path;

    let start = Instant::now();
    let rft = RFaultTree::new_random(
        n_nodes,
        config,
        comm.prob_multiplier,
        comm.perc_last,
        seed,
        comm.max_n_children,
    );

    match solver_cmd {
        Option::None => {
            rft.save_to_dft(output_filename);
            let duration = start.elapsed();
            println!(
                "{}",
                json!({
                    "time_elapsed": format!("{:?}", duration),
                })
            );
        }
        Option::Some(cmd) => {
            let solver = get_solver_from_path(cmd);
            rft.save_to_dft(output_filename);
            let ft = rft.extract_ft();
            let tep = solver.compute(
                &ft,
                CNFFormat::MC21,
                1.0,
                comm.timeout_s,
                None,
                false,
                false,
            );
            let duration = start.elapsed();

            println!(
                "{}",
                json!({
                    "tep": tep,
                    "time_elapsed": format!("{:?}", duration),
                })
            );
        }
    }
}

fn main() {
    let arguments = Arguments::parse();
    match arguments.command {
        Command::Info(command) => ft_info(command),
        Command::Solve(command) => compute_tep(command),
        Command::Translate(command) => translate(command),
        Command::Importance(command) => compute_importance_measures(command),
        Command::Modularize(command) => modularize_ft(command),
        Command::Rft(command) => random_ft(command),
    }
}
